<h1>ExportSymbolInstanceGeo</h1>
<p>Revit C# .NET add-in that exports selected element symbol and instance geometry triangles.</p>
<ul>
<li><a href="#1.1">Task &ndash; First Iteration</a></li>
<li><a href="#1.2">Discussion of First Iteration</a></li>
<li><a href="#1.3">No Nested Families</a></li>
<li><a href="#1.4">Handling Nested Families</a></li>
<li><a href="#2">Second Iteration &ndash; Export FamilyInstance Geometry as FamilySymbol Plus Translation</a></li>
</ul>
<h2><a name="1.1"></a>Task &ndash; First Iteration</h2>
<p>Export element triangles.</p>
<p>Given the currently selected element, export exhaustive information about its geometry to JSON, e.g., to <code>element.json</code>, like this:</p>
<p><code>{ "element_id": "d7a856d0-2e09-4ca6-83b0-9e7a18885b28-0012c5cf-1",
  "solids": [ { "faces": [ { "triangles": [ {
  "/": "these are the 3 coordinates of the 3 vertices of the triangle. The order doesn't matter as long as its consistent",
  "coords": [10, 11, 12, 1, 2, 3, 21, 22, 23] }, { "coords": [14, 11, 12, 1, 2, 3, 21, 22, 23] } ] } ] } ] }</code></p>
<p>The same json needs to be exported from the <code>FamilySymbol</code> to another file, e.g., <code>family_symbol.json</code>, with some translation info, e.g., <code>translation.json</code>, like this:</p>
<p><code>{ "rotation_matrix": [1,0,0,0,1,0,0,0,1], "translation": [1,2,3], ... }</code></p>
<p>such that, given family_symbol.json and translation.json, we can recreate element.json.</p>
<p>Note that we need to support all types of faces (just triangulate them).</p>
<h2><a name="1.2"></a>Discussion of First Iteration</h2>
<p>So, we implement the export of both element geometry and the transformed family definition geometry, all of the files mentioned above?</p>
<p>So, we export all types of faces, triangulated.</p>
<p>How about curves? Do they need to be supported at all, or can they just be ignored? &ndash; let's ignore them for now.</p>
<p>I would suggest some improvements to the above:</p>
<p>In elements.json, i would store the coordinates in a separate list, and reference that from the triangles. that saves repeating the same coordinates three or more times for different triangles.</p>
<p>Besides family_symbols.json and translation.json, we need a family_instances.json that refers to them both and says family instance element id X makes use of family symbol Y with translation Z.</p>
<p>In fact, I would store all the required information in one single file, containing:</p>
<p>a list of all XYZ points used
a list of all family symbols with their id and geometry definition, i.e., triangles.
a list of all family instances with their id, family symbol id and transform.</p>
<p>The entire solution needs to work only for the currently selected element.</p>
<p>Note that this entire task is only a proof of concept.</p>
<p>It will obviously need to be extended further to be used in production scenarios.</p>
<p>Saving the list of vertices separately is useful in two ways: it saves space, and, more importantly, helps ensure that the vertices and coordinates and triangles are really consistent.
It is actually easier to do that properly and minimally than to repeat the data unnecessarily.</p>
<p>Picking an individual element is a rather spacial case.
For production use, handling all elements in one go using
a <a href="https://thebuildingcoder.typepad.com/blog/about-the-author.html#5.1">custom exporter</a> makes more sense.</p>
<p>For selected elements, I once implemented
the <a href="https://github.com/jeremytammik/TwglExport">tiny WebGL exporter</a>.</p>
<p>Picking an individual element and accessing its geometry is not the recommended approach to export its triangulated solids, as I point out in the discussions implementing TwglExport:</p>
<ul>
<li><a href="https://thebuildingcoder.typepad.com/blog/2015/04/exporting-3d-element-geometry-to-a-webgl-viewer.html">Exporting 3D Element Geometry to a WebGL Viewer</a></li>
<li><a href="https://thebuildingcoder.typepad.com/blog/2015/04/live-revit-element-rendering-in-remote-webgl-viewer.html">Live Revit Element Rendering in Remote WebGL Viewer</a></li>
</ul>
<p>For a production scenario, one should rather go for the custom exporter solution, not select an individual element.</p>
<p>I also ((over-?) optimisticaly) believe that the custom exporter helps automatically solve the issue of differentiating between family instances that require individual geometry versus those that can reuse the symbol geometry.</p>
<h2><a name="1.3"></a>No Nested Families</h2>
<p>The first version of the per-element exporter is completed and tested in release 2020.0.0.1.</p>
<p>It only supports symbols one level deep.</p>
<p>It has assertions built in that fire if you try to use it on more nested family definitions.</p>
<p>We will have to completely reconsider and rethink the situation if that case needs to be handled also.</p>
<h2><a name="1.4"></a>Handling Nested Families</h2>
<p>Here is an idea on how to handle nested family instances:</p>
<p>Only support symbol definitions one level deep.</p>
<p>Any symbols that are nested within a top-level symbol are subsumed into the top-level symbol.
No nested symbol geometry is managed.
The nested symbol geometry is transformed up to the top-level symbol.</p>
<p>One complication is that this may create several different versions of the top-level symbol, and these need to be told apart.</p>
<p>For instance, imagine we have a door family D equipped with different nested door handles H.
Further, assume D defines a type == symbol D1, and H defines two types H1 and H2.
Assume the project contains three instances: D1 with H1 and D1 with H2.
This will generate two symbol definitions for D1.
How do we identify them, how to tell them apart?</p>
<h2><a name="2"></a>Second Iteration &ndash; Export FamilyInstance Geometry as FamilySymbol Plus Translation</h2>
<p>Let's make a new start with a new command based on the experience gathered from the first attempt.</p>
<p>The goal is to export the geometric information about a specific element.</p>
<p>The command is launched by selecting a specific FamilyInstance and clicking "export geometry".</p>
<p>Export 3 files (suggested format attached):</p>
<ul>
<li><a href="example/family_instance_geometry.json">family_instance_geometry.json</a> &ndash;
exhaustive information regarding the geometry of the instance. See the attached
<a href="example/example_export.cs">example_export.cs</a> for suggested traversal code. </li>
<li><a href="example/family_symbol_geometry.json">family_symbol_geometry.json</a> &ndash;
exhaustive information regarding the general family symbol</li>
<li><a href="example/family_instance_translation_info.json">family_instance_translation_info.json</a> &ndash;
information regarding the translation of the specific element to reach its</li>
</ul>
<p>Also implement code that can take <code>family_symbol_geometry</code> + <code>family_instance_translation_info</code> and create the <code>family_instance_geometry</code> file from it.</p>
<p>Notes:</p>
<ul>
<li>If the instance has sub-elements, skip it.</li>
<li>Work only on the currently selected element (obviously, it will be modified to work on all elements later).</li>
<li>Need to support all types of faces (just triangulate them using <code>face.Triangulate(LevelOfDetail)</code>).</li>
<li>No need to support other types of geometries (PolyLine, Point, Curve, ...). Just Solid and Mesh.</li>
<li>Please do not export the vertices separately from their indices. Although I understand the value of that, it makes the code less clear at this point.</li>
<li>The code should work for elements in linked models as well.</li>
</ul>
<h2><a name="author"></a>Author</h2>
<p>Jeremy Tammik, <a href="http://thebuildingcoder.typepad.com">The Building Coder</a>, <a href="http://www.autodesk.com/adn">ADN</a> <a href="http://www.autodesk.com/adnopen">Open</a>, <a href="http://www.autodesk.com">Autodesk Inc.</a></p>
<h2><a name="license"></a>License</h2>
<p>This sample is licensed under the terms of the <a href="http://opensource.org/licenses/MIT">MIT License</a>.
Please see the <a href="LICENSE">LICENSE</a> file for full details.</p>